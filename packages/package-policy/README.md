# Package Policy

This package implements a generic, enforceable, event-emitting custom upgrade policy for Sui Move packages. It provides a transparent, on-chain, and auditable process for managing package upgrades.

## 1. Motivation

The primary motivation for this package is to enhance the transparency and verifiability of smart contract governance on Sui. Standard package upgrades do not emit on-chain events, making it difficult for users and community members to track code changes.

This policy addresses that by ensuring every step of the upgrade process is accompanied by a descriptive on-chain event, aligning with a core philosophy of "do not trust, verify." By making governance actions explicit and observable, we build greater trust with our users.

Although developed for a specific use case, this package is intentionally generic and can be used to govern any Sui package.

## 2. Technical Implementation

This policy uses **Direct Wrapping** to implement an **object locking** pattern. This is a standard and secure method for creating enforceable custom upgrade policies by locking the real `sui::package::UpgradeCap` inside our custom `PolicyCap` object.

This pattern is detailed in the official Sui documentation:

- [Custom Upgrade Policies](https://docs.sui.io/concepts/sui-move-concepts/packages/custom-policies)
- [Wrapped Objects](https://docs.sui.io/concepts/object-ownership/wrapped)

The core components are:

- **`PolicyCap`**: A custom capability struct that "locks" the real `sui::package::UpgradeCap` inside it. The owner of this `PolicyCap` has the authority to upgrade the governed package.
- **Events**: The policy emits three distinct events to provide a full audit trail:
  - `PolicyCreated`: Emitted once when an `UpgradeCap` is locked into the policy.
  - `UpgradeAuthorized`: Emitted when an upgrade is initiated, signaling the intent to upgrade.
  - `ContractUpgraded`: Emitted after the upgrade is finalized, recording the old and new package IDs.

### Lifecycle

1.  **Locking the Policy**: To enforce this policy, the owner of a package performs a one-time call to `policy::create`, passing in their `UpgradeCap`. This function consumes the original `UpgradeCap` and returns a `PolicyCap` object to the owner.
2.  **Performing Upgrades**: Once the policy is locked, all future upgrades must be performed by calling `policy::authorize_upgrade` and `policy::commit_upgrade`, which require the owner to present their `PolicyCap`. This guarantees that the corresponding events are always emitted.

## 3. Notes and Considerations

- **Enforcement is a One-Way Action**: Locking an `UpgradeCap` by calling `policy::create` is an irreversible action. Once the `UpgradeCap` is wrapped in a `PolicyCap`, it cannot be retrieved. The policy becomes mandatory for the lifetime of that package.

- **Security Model**: The security of any package governed by this policy rests entirely on the security of the account holding the `PolicyCap`.

### Hardening the Policy Contract

For maximum security and trust, the `package-policy` contract itself should be hardened. There are two primary strategies to achieve this, each offering different trade-offs:

1.  **Self-Locking for Transparent Upgrades**: The owner of this `package-policy` contract can lock its own `UpgradeCap` inside a `PolicyCap` generated by this same module. This ensures that any future upgrades to the policy contract itself must follow the policy's rules, emitting events and providing full on-chain transparency. This approach maintains the flexibility to add new features (like timelocks) while ensuring all changes are auditable.

2.  **Permanent Immutability for Absolute Finality**: For the strongest possible guarantee that the policy rules will _never_ change, the owner can make the `package-policy` contract immutable by calling `sui::package::make_immutable` on its own `UpgradeCap`. This action is irreversible and means no bug fixes or future enhancements can ever be deployed. This option should be considered if the policy is deemed absolutely complete and final.
